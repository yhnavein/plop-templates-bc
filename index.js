'use strict';

const path = require('path');
const fs = require('fs-extra');

let sharedComponentsDir = 'src/app/components/';
let mainComponentsDir = 'src/app/';
let componentsIndexFile = 'src/app/components/index.ts';
let indexModuleFile = 'src/app/index.module.ts';
const plopTemplates = path.resolve(__dirname, './templates/');

/** Helper Functions */

function isPathAvailable(dir, name) {
  return !fs.existsSync(path.join(dir, name));
}

function toCamel(name) {
  return name.toLowerCase().replace(/-(.)/g, (match, group) => group.toUpperCase() );
}

function toDash(name) {
  return name.replace( /([a-z])([A-Z])/g, '$1-$2' ).toLowerCase();
}

function generateNames(name) {
  const niceName = name.replace(/\s+/g, ' ');
  const dashName = toDash(niceName.split(' ').join('-'));

  return {
    fileName: dashName,
    className: capitalize(toCamel(dashName)),
    cssName: toCamel(dashName),
    niceName: capitalize(niceName)
  }
}

function capitalize(name) {
  if(!name)
    return null;

  return name.charAt(0).toUpperCase() + name.slice(1);
}

function removeFiles(destDir, filePattern) {
  fs.removeSync(path.join(destDir, filePattern));
}

function copyFiles(srcDir, destDir, fileName) {
  fs.mkdirpSync(destDir);
  const files = fs.readdirSync(srcDir);
  files.forEach(f => {
    fs.copySync(path.join(srcDir, f), path.join(destDir, f.replace('_name', fileName)));
  });
}

function modifyFiles(dir, fn) {
  const newFiles = fs.readdirSync(dir);
  newFiles.forEach(f => {
    const fileName = path.join(dir, f);
    const fileContent = fn(fs.readFileSync(fileName, 'utf-8'));

    fs.writeFileSync(fileName, fileContent, 'utf-8');
  });

  return newFiles.length;
}

function appendToFile(filePath, regType, text) {
  const regex = new RegExp('\\/\\*+\\s+\\@plopInject\\[' + regType + '\\]');
  let fileContent = fs.readFileSync(filePath, 'utf-8');
  const patternIndex = fileContent.search(regex);

  if(patternIndex < 0)
    return;

  fileContent = fileContent.slice(0, patternIndex) + (text + '\n') + fileContent.slice(patternIndex);

  fs.writeFileSync(filePath, fileContent, 'utf-8');
}

function validateName(value, destDir) {
  if (!(/.+/).test(value))
    return 'Empty Name provided. Try again';

  const name = generateNames(value).fileName;
  if (!isPathAvailable(destDir, name))
    return 'There is already component with provided name! Try again';

  return true;
}

/** Generators */

module.exports = (plop, config) => {
  // Config defaults.
  config = config || {};
  config.basePath = config.basePath || './';

  plop.setGenerator('Reusable Component', {
    description: 'A new component that you wish to appear in multiple places',
    prompts: [
      {
        type: 'input',
        name: 'name',
        message: 'Please provide a component name:',
        validate: (value) => validateName(value, sharedComponentsDir)
      }
    ],
    actions: [
      function run(answers) {
        process.chdir(plop.getPlopfilePath());

        const names = generateNames(answers.name);
        const destDir = path.join(sharedComponentsDir, names.fileName);
        const srcDir = path.join(plopTemplates, 'sharedComponent');

        try {
          copyFiles(srcDir, destDir, names.fileName);

          const filesChanged = modifyFiles(destDir,
            (fileContent) => plop.renderString(fileContent, names)
          );

          appendToFile(componentsIndexFile, 'export', `export * from './${names.fileName}/${names.fileName}.component';`)
          appendToFile(componentsIndexFile, 'import', `import { ${names.className} } from './${names.fileName}/${names.fileName}.component';`)
          appendToFile(componentsIndexFile, 'body', `    app.component('${names.cssName}', new ${names.className}());`)

          return `${filesChanged} files autogenerated for you in ${destDir}`;
        }
        catch (err) {
          return 'Error when copying files';
        }
      }
    ]
  });

  plop.setGenerator('Reusable Directive (TODO)', {
    description: 'A new directive that you wish to appear in multiple places (more robust than component)',
    prompts: [
      {
        type: 'input',
        name: 'name',
        message: 'Please provide a component name:',
        validate: (value) => validateName(value, sharedComponentsDir)
      }
    ],
    actions: []
  });

  plop.setGenerator('Page Component', {
    description: 'A new component with a routing configured',
    prompts: [
      {
        type: 'input',
        name: 'name',
        message: 'Please provide a page name:',
        validate: (value) => validateName(value, mainComponentsDir)
      }, {
        type: 'input',
        name: 'modelName',
        message: 'Please provide a model name: (leave empty to omit)',
        validate: (value) => {
          if(value && value.length > 0 && !/^[a-z]+$/i.test(value))
            return 'Only letters, please';

          return true;
        }
      }
    ],
    actions: [
      function run(answers) {
        process.chdir(plop.getPlopfilePath());

        const names = generateNames(answers.name);
        const modelName = capitalize(answers.modelName);
        const destDir = path.join(mainComponentsDir, names.fileName);
        const srcDir = path.join(plopTemplates, 'pageComponent');

        names.modelName = modelName;

        try {
          copyFiles(srcDir, destDir, names.fileName);

          if(!modelName)
            removeFiles(destDir, '*.model.ts');

          const filesChanged = modifyFiles(destDir,
            (fileContent) => plop.renderString(fileContent, names)
          );

          appendToFile(indexModuleFile, 'import', `import { ${names.className} } from './${names.fileName}';`)
          appendToFile(indexModuleFile, 'body', `  ${names.className}.bootstrap();`)

          return `${filesChanged} files autogenerated for you in ${destDir}`;
        }
        catch (err) {
          return 'Error when copying files';
        }
      }
    ]
  });

  plop.setGenerator('Test Naming Method', {
    description: 'You can see here how provided name will be transformed [won\'t touch your files]',
    prompts: [
      {
        type: 'input',
        name: 'testName',
        message: 'Test Component Name:',
        validate: (value) => {
          var names = generateNames(value);
          console.log('\n' + JSON.stringify(names, null, '  '));
        }
      }
    ]
  });


};